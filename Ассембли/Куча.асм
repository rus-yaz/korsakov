;format ELF64 executable
;entry _start

format ELF64
public _start

include "utils.asm"

section "data" writable
  include "defines.asm"

  ; Куча
  HEADER_SIGN dq 0xFEDCBA9876543210 ; Обозначение начала заголовка блока, выделяемого на куче
  HEAP_SIZE   dq 0x1000             ; Начальный размер кучи
  heap_start  rq 1                  ; Указатель на начало кучи
  heap_end    rq 1                  ; Указатель на конец кучи

  ; Сообщения об ошибках
  HEAP_ALLOCATION_ERROR            db "Ошибка аллокации кучи", 10, 0
  EXPECTED_INTEGER_TYPE_ERROR      db "Ожидался тип Целое число", 10, 0
  EXPECTED_LIST_TYPE_ERROR         db "Ожидался тип Список", 10, 0
  EXPECTED_INTEGER_LIST_TYPE_ERROR db "Ожидался тип Целое число или Список", 10, 0
  EXPECTED_HEAP_BLOCK_ERROR        db "Ожидался блок кучи", 10, 0
  INDEX_OUT_OF_LIST_ERROR          db "Индекс выходит за пределы списка", 10, 0
  OPENING_FILE_ERROR               db "Не удалось открыть файл", 10, 0

  filename db "file", 0
  file_desc rq 1
  buffer db 1024 dup(0)
  buffer_size dq 1024

  список rq 1
  индекс rq 1

section "write_header" executable

; Установка заголовка блока
;
; Аргументы:
;   addr        — указатель на заголовок блока
;   header_sign — метка заголовка блока
;   size        — размер тела блока
;   prev_size   — размер тела предыдущего блока
;   state       — состояние использования блока

macro write_header addr, header_sign, size, prev_size, state {
  mem_mov [addr + 8*0], header_sign
  mem_mov [addr + 8*1], size
  mem_mov [addr + 8*2], prev_size
  mem_mov [addr + 8*3], state
}


section "allocate_heap" executable

; Алллокация кучи с сохранением указателей на начало и конец кучи
;
; Аргументы:
;   HEAP_SIZE — размер выделяемой кучи
;
; Результат:
;   heap_start — указатель на начало кучи
;   heap_end   — указатель на начало кучи

macro allocate_heap {
  enter

  call f_allocate_heap

  leave
}

f_allocate_heap:
  syscall_6 SYS_MMAP,\
            0,\                                  ; Адрес (если 0, нахоходится автоматически)
            [HEAP_SIZE],\                        ; Количество памяти для аллокации
            PROT_READ + PROT_WRITE + PROT_EXEC,\ ; Права (PROT_READ | PROT_WRITE)
            MAP_SHARED + MAP_ANONYMOUS,\         ; MAP_ANONYMOUS | MAP_PRIVATE
            0,\                                  ; Файл дескриптор (ввод)
            0                                    ; Смещение относительно начала файла (с начала файла)

  ; Проверка корректности выделения памяти
  test rax, rax
  check_error js, HEAP_ALLOCATION_ERROR

  ; Сохранение указателя на начало кучи
  mov [heap_start], rax

  mov rbx, [HEAP_SIZE]                       ; Запись размера кучи
  sub rbx, 8*4                               ; Учёт размера заголовка блока
  write_header rax, [HEADER_SIGN], rbx, 0, 0 ; Запись заголовка начального блока

  mov rax, [heap_start] ; Запись указателя на начало кучи
  add rax, [HEAP_SIZE]  ; Смещение на размер кучи
  mov [heap_end], rax   ; Сохранение указателя на конец кучи

  ret

section "expand_heap" executable

; Расширение кучи
;
; Аргументы:
;   size — количество памяти, на которое необходимо расширить кучу
;
; Результат:
;   heap_start — указатель на начало кучи
;   heap_end   — указатель на начало кучи

macro expand_heap size {
  enter_1 size

  call f_expand_heap

  leave
}

f_expand_heap:
  ; Сохранение количества памяти для расширения
  mov rcx, rax

  ; Получение итогового размера кучи
  add rax, [HEAP_SIZE]
  mov [HEAP_SIZE], rax

  ; Взятие указателя на начало кучи
  mov rax, [heap_start]

  ; Аллокация новой кучи
  allocate_heap

  ; RDI — указатель на новую кучу
  ; RSI — указатель на старую кучу
  mov rdi, [heap_start]
  mov rsi, rax

  ; Сохранение указателя на старую кучу
  mov r8, rsi

  ; Получение размера старой кучи
  mov rax, [HEAP_SIZE]
  sub rax, rcx

  ; Сохранение размера старой кучи
  mov r9, rax

  ; Расчёт количества операций для копирования
  push rax
  mov rcx, 8
  idiv rcx
  mov rcx, rax
  pop rax

  ; Копирование данных со старой кучи в новую
  rep movsq

  ; Укзатель на начало новой кучи
  mov rbx, [heap_start]

  ; Поиск последнего блока кучи
  .while:
    mov rcx, rbx
    add rbx, [rbx + 8*1]
    add rbx, 8*4

    mov rdx, [rbx]
    cmp rdx, [HEADER_SIGN]
    je .while

  ; Расширение последнего блока до конца кучи
  mov rbx, [rcx + 8*1]
  add rbx, rax
  mov [rcx + 8*1], rbx

  ; Деаллокация старой кучи
  syscall_2 SYS_MUNMAP,\
            r8,\
            r9

  ret

section "create_block" executable

; Аллоакция места на куче для блока определённого размера
;
; Аргументы:
;   size — количество памяти, выделяемой на тело блока
;
; Результат:
;   rax — указатель на тело блока

macro create_block size {
  enter_1 size

  call f_create_block

  leave_with_return
}

f_create_block:
  mov r8, rax

  mov rax, [heap_start] ; Запись указателя на начало кучи в RAX

  ; Цикл для нахождения подходящего блока
  .do:
    ; Если заголовок не найден, выйти с ошибкой
    mov rdx, [rax]
    cmp rdx, [HEADER_SIGN]
    check_error jne, EXPECTED_HEAP_BLOCK_ERROR

    ; Если блок используется, начать искать новый блок
    mov rdx, [rax + 8*3]
    test rdx, 1
    js .condition

    ; Сравнение выделенного размера и размера блока
    mov rdx, [rax + 8*1]
    cmp rdx, r8
    jge .continue

  .condition:
    add rax, [rax + 8*1] ; Смещение адреса текущего блока на его размер
    add rax, 8*4         ; Смещение адреса текущего указателя на размер заголовка

    jmp .do  ; Переход к началу цикла

  ; Окончание цикла
  .continue:
    ; Вычисление адреса нового блока
    mov rbx, rax
    add rbx, 8*4
    add rbx, r8

    ; Проверка состояния блока
    mov rcx, [rbx + 8*3]
    test rcx, 1
    jnz .do

  .modify_block:

  mem_mov [rax + 8*3], 1 ; Изменение состояния текущего блока на используемое

  mov rcx, [rax + 8*1]    ; Сохранение размера текущего блока в RCX
  sub rcx, r8             ; Вычисление размера текущего блока в RCX
  sub rcx, 8*4            ; Учёт размера заголовка
  mem_mov [rax + 8*1], r8 ; Изменение SIZE у предыдущего блока

  ; KEY
  ; SIZE
  ; PREV_SIZE
  ; STATE
  write_header rbx, [HEADER_SIGN], rcx, r8, 0

  add rax, 8*4

  ret

section "delete_block" executable

; Удаление блока по указателю
;
; Аргументы:
;   block_addr — указатель на блок
macro delete_block block_addr {
  enter block_addr

  call f_delete_block

  leave
}

f_delete_block:
  sub rax, 8*4

  mov r8, rax

  ; Если заголовок не найден, выйти с ошибкой
  mov rax, [r8]
  cmp rax, [HEADER_SIGN]
  check_error jne, EXPECTED_HEAP_BLOCK_ERROR

  ; Объединение текущего блока и следующего, если он не используется

  ; Нахождение следующего блока
  mov rax, r8
  add rax, 8*4
  add rax, [r8 + 8*1]

  ; Если заголовок не найден (блока не существует), пропустить изменение блоков
  mov rbx, [rax]
  cmp rbx, [HEADER_SIGN]
  jne .skip_current_and_next_blocks_merging

  ; Если следующий блок используется, пропустить изменение блоков
  mov rbx, [rax + 8*3]
  test rbx, 1
  jne .skip_current_and_next_blocks_merging

  ; Увеличение размера текущего блока на размер удаляемого блока
  mov rcx, [r8 + 8*1]
  add rcx, [rax + 8*1]
  add rcx, 8*4
  mov [r8 + 8*1], rcx

  ; Удаление заголовка удаляемого блока
  write_header rax, 0, 0, 0, 0

  .skip_current_and_next_blocks_merging:

    ; Нахождение предыдущего блока
    mov rax, r8
    sub rax, [r8 + 8*2]
    sub rax, 8*4

    ; Проверка нахождения блока внутри кучи
    cmp rax, [heap_start]
    jl .skip_previous_and_current_blocks_merging

    ; Если заголовок не найден (блока не существует), пропустить изменение блоков
    mov rbx, [rax]
    cmp rbx, [HEADER_SIGN]
    jne .skip_previous_and_current_blocks_merging

    ; Если следующий блок используется, пропустить изменение блоков
    mov rbx, [rax + 8*3]
    test rbx, 1
    jne .skip_previous_and_current_blocks_merging

    ; Увеличение размера предыдущего блока на размер удаляемого блока
    mov rcx, [r8 + 8*1]
    add rcx, [rax + 8*1]
    add rcx, 8*4
    mov [rax + 8*1], rcx

    ; Удаление заголовка удаляемого блока
    write_header r8, 0, 0, 0, 0
    mov r8, rax

  .skip_previous_and_current_blocks_merging:

    ; Изменение состояния текущего блока
    mov rax, [r8 + 8*3]
    test rax, 1
    jz .all_is_done
    mem_mov [r8 + 8*3], 0

  .all_is_done:

  ; Нахождение дальше идущего блока
  mov rcx, r8
  add rcx, [r8 + 8*1]
  add rcx, 8*4

  ; Проверка нахождения блока внутри кучи
  mov rax, [heap_end]
  cmp rcx, [heap_end]
  jge .skip_next_next_block_modifying

  ; Если заголовок не найден (блока не существует), пропустить изменение блоков
  mov rbx, [rcx]
  cmp rbx, [HEADER_SIGN]
  jne .skip_next_next_block_modifying

  ; Изменение PREV_SIZE для дальше идущего блока
  mem_mov [rcx + 8*2], [r8 + 8*1]

  .skip_next_next_block_modifying:

  ret

section "create_integer" executable

macro create_integer value {
  pushq value
  pushq INTEGER
}

section "create_list" executable

; Запись списка на кучу
;
; Аргументы:
;   list_start — указатель на начало списка
;
; Результат:
;   rax — указатель на созданный блок

macro create_list list_start, length {
  enter_2 list_start, length

  call f_create_list

  leave_with_return
}

f_create_list:
  ; Сохранение указателя на начало копируемого списка и длины списка
  push rax
  push rbx

  mov rcx, LIST_HEADER

  .do:
    dec rbx

    mov rdx, [rax]
    cmp rdx, INTEGER
    jne .not_integer

    add rcx, 2
    add rax, 8*2
    jmp .while

  .not_integer:
    cmp rax, LIST
    jne .not_list

    add rcx, LIST_HEADER
    add rcx, [rax + 8*1]
    add rax, [rax + 8*2]

    jmp .while

  .not_list:
    check_error jmp, EXPECTED_INTEGER_LIST_TYPE_ERROR

  .while:
    cmp rbx, 0
    jne .do

  mov rbx, rcx
  imul rbx, 8

  ; Аллокация блока на куче
  create_block rbx

  ; Возвращение длины списка
  pop rbx

  write_header rax, LIST, rbx, rcx, 0

  ; RCX — количество блоков
  mov rbx, LIST_HEADER
  sub rcx, rbx
  imul rbx, 8
  mov rdi, rax ; Место назначения
  add rdi, rbx
  pop rsi      ; Источник копирования
  rep movsq    ; Копирование в аллоцированный блок

  ret

section "list_length" executable

macro list_length list_ptr {
  enter_1 list_ptr

  call f_list_length

  leave_with_return
}

f_list_length:
  mov rbx, [rax]
  cmp rbx, LIST
  check_error jne, EXPECTED_LIST_TYPE_ERROR

  mov rax, [rax + 8*1]

  ret

section "list_get" executable

; Запись списка на кучу
;
; Аргументы:
;   list_ptr  — указатель на начало списка
;   index_ptr — указатель на целое число, индекс
;
; Результат:
;   rax — указатель на элемент по индексу

macro list_get list_ptr, index_ptr {
  enter_2 list_ptr, index_ptr

  call f_list_get

  leave_with_return
}

f_list_get:
  ; Проверка типа
  mov rcx, [rax]
  cmp rcx, LIST
  check_error jne, EXPECTED_LIST_TYPE_ERROR

  ; Проверка типа
  mov rcx, [rbx]
  cmp rcx, INTEGER
  check_error jne, EXPECTED_INTEGER_TYPE_ERROR

  ; Запись длины списка
  mov rcx, [rax + 8*1]

  ; Если индекс меньше нуля, то увеличить его на длину списка
  mov rbx, [rbx + 8*1]
  cmp rbx, 0
  jge .positive_index
  add rbx, rcx

  .positive_index:

  ; Проверка, входит ли индекс в список
  cmp rbx, rcx
  check_error jge, INDEX_OUT_OF_LIST_ERROR
  cmp rbx, 0
  check_error jl, INDEX_OUT_OF_LIST_ERROR

  mov rcx, rax
  mov rdx, LIST_HEADER
  imul rdx, 8
  add rcx, rdx

  .while:
    dec rbx

    cmp rbx, 0
    jl .while_end

  .do:
    mov rax, [rcx]

    cmp rax, INTEGER
    jne .not_integer

    add rcx, 8*2 ; Смещение на размер заголовка и размер тела
    jmp .while

  .not_integer:
    cmp rax, LIST
    jne .not_list

    mov rax, [rcx + 8*2]
    add rax, LIST_HEADER
    imul rax, 8
    add rcx, rax

    jmp .while

  .not_list:
    check_error jmp, EXPECTED_INTEGER_LIST_TYPE_ERROR

  .while_end:

    mov rax, rcx

  ret

section "get_file_size" executable

macro get_file_size filename {
  enter_1 filename

  call f_get_file_size

  leave_with_return
}

f_get_file_size:
  mov rdi, rax ; Указатель на имя файла

  create_block STAT_BUFFER_SIZE

  mov rbx, rax

  syscall_2 SYS_STAT,\
            rdi,\      ; Указатель на имя файла
            rax        ; Указатель на место хранения данных

  mov rax, [rbx + 48] ; Размер файла в байтах

  ret

section "open_file" executable

macro open_file filename {
  enter_1 filename

  call f_open_file

  leave_with_return
}

f_open_file:
  ; Открытие файла
  syscall_2 SYS_OPEN,\
            rax,\      ; Указатель на имя файла
            O_RDONLY   ; Параметры открытия файла

  ; Проверка открытия файла
  cmp rax, 0
  check_error jle, OPENING_FILE_ERROR

  ; Сохраняем дескриптор файла
  mov [file_desc], rax

  ret

section "read_file" executable

macro read_file file_descriptor {
  enter_1 file_descriptor

  call f_read_file

  leave_with_return
}

section "close_file" executable

macro close_file file_descriptor {
  enter_1 file_descriptor

  call f_read_file

  leave_with_return
}

f_close_file:
  ; Закрываем файл
  syscall_1 SYS_CLOSE,\
            [rax]      ; Дескриптор файла
  ret


f_read_file:
  mov rbx, rax

  ; Читаем содержимое файла
  syscall_3 SYS_READ,\
            [rax],\       ; Дескриптор файла
            buffer,\      ; Буфер для хранения данных
            [buffer_size] ; Размер буфера

  ; Проверяем, прочитано ли что-то
  cmp rax, 0
  jge .skip                   ; если < 0, выходим

    close_file rbx

  .skip:
  ret

section "start" executable
_start:
  allocate_heap

  get_file_size filename
  print_int rax

  open_file filename

  read_file file_desc

  ; Выводим содержимое файла
  print buffer, [buffer_size]

  close_file file_desc

  ; Аллокация кучи
  allocate_heap

  ; Расширение кучи
  expand_heap 0x1000

  ; список = 1 2 3 4
  create_integer 4
  create_integer 3
  create_integer 2
  create_integer 1

  mov rax, rsp ; Указатель на начало списка
  create_list rax, 4 ; Количество элементов

  mov [список], rax

  ; индекс = 999
  create_integer -1
  mov [индекс], rsp

  ; список.индекс
  list_get [список], [индекс]
  exit [rax + 8*1] ; Показать значение взятогого элемента

  exit 0
