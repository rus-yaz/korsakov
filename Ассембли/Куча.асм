;format ELF64 executable
;entry _start

format ELF64
public _start

include "utils.asm"

section "data" writable
  include "defines.asm"

  ; Куча
  HEADER_SIGN dq 0xFEDCBA9876543210 ; Обозначение начала заголовка блока, выделяемого на куче
  HEAP_SIZE   dq 0x1000             ; Начальный размер кучи
  heap_start  rq 1                  ; Указатель на начало кучи
  heap_end    rq 1                  ; Указатель на конец кучи

  ; Сообщения об ошибках
  HEAP_ALLOCATION_ERROR               db "Ошибка аллокации кучи", 10, 0
  EXPECTED_INTEGER_TYPE_ERROR         db "Ожидался тип Целое число", 10, 0
  EXPECTED_LIST_TYPE_ERROR            db "Ожидался тип Список", 10, 0
  EXPECTED_STRING_TYPE_ERROR          db "Ожидался тип Строка", 10, 0
  EXPECTED_CHAR_TYPE_ERROR            db "Ожидался тип Символ", 10, 0
  EXPECTED_STRING_CHAR_TYPE_ERROR     db "Ожидался тип Строка или Символ", 10, 0
  EXPECTED_INTEGER_LIST_TYPE_ERROR    db "Ожидался тип Целое число или Список", 10, 0
  EXPECTED_FILE_DESCRIPTOR_TYPE_ERROR db "Ожидался тип Файловый дескриптор", 10, 0
  EXPECTED_HEAP_BLOCK_ERROR           db "Ожидался блок кучи", 10, 0
  INDEX_OUT_OF_LIST_ERROR             db "Индекс выходит за пределы списка", 10, 0
  OPENING_FILE_ERROR                  db "Не удалось открыть файл", 10, 0
  FILE_WAS_NOT_READ_ERROR             db "Файл не был прочитан", 10, 0
	UNEXPECTED_BIT_SEQUENCE_ERROR       db "Неизвестная битовая последовательность", 10, 0

	FILE_SIZE       db "Размер файла: ", 0
	STRING_SIZE     db "Размер строки (учитывается переноса): ", 0
	STRING_CONTENT  db 10, "Содержимое строки:", 10, 0
	CHAR_BY_INDEX   db "Символ по индексу: ", 0

  filename db "привет.корс", 0

  список rq 1
  индекс rq 1
  файловый_дескриптор rq 1
	содержимое_файла rq 1
	символ rq 1

section "write_header" executable

; Установка заголовка блока
;
; Аргументы:
;   addr        — указатель на заголовок блока
;   header_sign — метка заголовка блока
;   size        — размер тела блока
;   prev_size   — размер тела предыдущего блока
;   state       — состояние использования блока

macro write_header addr, header_sign, size, prev_size, state {
  mem_mov [addr + 8*0], header_sign
  mem_mov [addr + 8*1], size
  mem_mov [addr + 8*2], prev_size
  mem_mov [addr + 8*3], state
}


section "allocate_heap" executable

; Алллокация кучи с сохранением указателей на начало и конец кучи
;
; Аргументы:
;   HEAP_SIZE — размер выделяемой кучи
;
; Результат:
;   heap_start — указатель на начало кучи
;   heap_end   — указатель на начало кучи

macro allocate_heap {
  enter

  call f_allocate_heap

  leave
}

f_allocate_heap:
  syscall_6 SYS_MMAP,\
            0,\                                  ; Адрес (если 0, находится автоматически)
            [HEAP_SIZE],\                        ; Количество памяти для аллокации
            PROT_READ + PROT_WRITE + PROT_EXEC,\ ; Права (PROT_READ | PROT_WRITE)
            MAP_SHARED + MAP_ANONYMOUS,\         ; MAP_ANONYMOUS | MAP_PRIVATE
            0,\                                  ; Файл дескриптор (ввод)
            0                                    ; Смещение относительно начала файла (с начала файла)

  ; Проверка корректности выделения памяти
  test rax, rax
  check_error js, HEAP_ALLOCATION_ERROR

  ; Сохранение указателя на начало кучи
  mov [heap_start], rax

  mov rbx, [HEAP_SIZE]                       ; Запись размера кучи
  sub rbx, 8*4                               ; Учёт размера заголовка блока
  write_header rax, [HEADER_SIGN], rbx, 0, 0 ; Запись заголовка начального блока

  mov rax, [heap_start] ; Запись указателя на начало кучи
  add rax, [HEAP_SIZE]  ; Смещение на размер кучи
  mov [heap_end], rax   ; Сохранение указателя на конец кучи

  ret

section "expand_heap" executable

; Расширение кучи
;
; Аргументы:
;   size — количество памяти, на которое необходимо расширить кучу
;
; Результат:
;   heap_start — указатель на начало кучи
;   heap_end   — указатель на начало кучи

macro expand_heap size {
  enter_1 size

  call f_expand_heap

  leave
}

f_expand_heap:
  ; Сохранение количества памяти для расширения
  mov rcx, rax

  ; Получение итогового размера кучи
  add rax, [HEAP_SIZE]
  mov [HEAP_SIZE], rax

  ; Взятие указателя на начало кучи
  mov rax, [heap_start]

  ; Аллокация новой кучи
  allocate_heap

  ; RDI — указатель на новую кучу
  ; RSI — указатель на старую кучу
  mov rdi, [heap_start]
  mov rsi, rax

  ; Сохранение указателя на старую кучу
  mov r8, rsi

  ; Получение размера старой кучи
  mov rax, [HEAP_SIZE]
  sub rax, rcx

  ; Сохранение размера старой кучи
  mov r9, rax

  ; Расчёт количества операций для копирования
  push rax
	mov rdx, 0
  mov rcx, 8
  idiv rcx
  mov rcx, rax
  pop rax

  ; Копирование данных со старой кучи в новую
  rep movsq

  ; Укзатель на начало новой кучи
  mov rbx, [heap_start]

  ; Поиск последнего блока кучи
  .while:
    mov rcx, rbx
    add rbx, [rbx + 8*1]
    add rbx, 8*4

    mov rdx, [rbx]
    cmp rdx, [HEADER_SIGN]
    je .while

  ; Расширение последнего блока до конца кучи
  mov rbx, [rcx + 8*1]
  add rbx, rax
  mov [rcx + 8*1], rbx

  ; Деаллокация старой кучи
  syscall_2 SYS_MUNMAP,\
            r8,\         ; Указатель на старую кучу
            r9           ; Размер старой кучи

  ret

section "create_block" executable

; Аллоакция места на куче для блока определённого размера
;
; Аргументы:
;   size — количество памяти, выделяемой на тело блока
;
; Результат:
;   rax — указатель на тело блока

macro create_block size {
  enter_1 size

  call f_create_block

  leave_with_return
}

f_create_block:
	; Приведение размера к числу, кратному 8
	mov rbx, 8
	mov rdx, 0
	idiv rbx

	mov rcx, rdx
	mov rdx, 0
	imul rbx

	cmp rcx, 0
	je .skip
		mov rdx, 8
		add rax, rdx
	.skip:

  mov r8, rax ; Сохранение размера создаваемого блока
  mov rax, [heap_start] ; Запись указателя на начало кучи в RAX

  ; Цикл для нахождения подходящего блока
  .do:
    ; Если заголовок не найден, выйти с ошибкой
    mov rdx, [rax]
    cmp rdx, [HEADER_SIGN]
    check_error jne, EXPECTED_HEAP_BLOCK_ERROR

    ; Если блок используется, начать искать новый блок
    mov rdx, [rax + 8*3]
    cmp rdx, 0
    jne .while

    ; Сравнение выделенного размера и размера блока
    mov rdx, [rax + 8*1]
    cmp rdx, r8
    jge .continue

  .while:
    add rax, [rax + 8*1] ; Смещение адреса текущего блока на его размер
    add rax, 8*4         ; Смещение адреса текущего указателя на размер заголовка

    jmp .do  ; Переход к началу цикла

  ; Окончание цикла
  .continue:
    ; Вычисление адреса нового блока
    mov rbx, rax
    add rbx, 8*4
    add rbx, r8

    ; Проверка состояния блока
    mov rcx, [rbx + 8*3]
    test rcx, 1
    jnz .do

  .modify_block:

  mem_mov [rax + 8*3], 1 ; Изменение состояния текущего блока на используемое

  mov rcx, [rax + 8*1]    ; Сохранение размера текущего блока в RCX
  sub rcx, r8             ; Вычисление размера текущего блока в RCX
  sub rcx, 8*4            ; Учёт размера заголовка
  mem_mov [rax + 8*1], r8 ; Изменение SIZE у предыдущего блока

  ; KEY
  ; SIZE
  ; PREV_SIZE
  ; STATE
  write_header rbx, [HEADER_SIGN], rcx, r8, 0

  add rax, 8*4

  ret

section "delete_block" executable

; Удаление блока по указателю
;
; Аргументы:
;   block_addr — указатель на блок
macro delete_block block_addr {
  enter_1 block_addr

  call f_delete_block

  leave
}

f_delete_block:
  sub rax, 8*4

  mov r8, rax

  ; Если заголовок не найден, выйти с ошибкой
  mov rax, [r8]
  cmp rax, [HEADER_SIGN]
  check_error jne, EXPECTED_HEAP_BLOCK_ERROR

  ; Объединение текущего блока и следующего, если он не используется

  ; Нахождение следующего блока
  mov rax, r8
  add rax, 8*4
  add rax, [r8 + 8*1]

  ; Если заголовок не найден (блока не существует), пропустить изменение блоков
  mov rbx, [rax]
  cmp rbx, [HEADER_SIGN]
  jne .skip_current_and_next_blocks_merging

  ; Если следующий блок используется, пропустить изменение блоков
  mov rbx, [rax + 8*3]
  test rbx, 1
  jne .skip_current_and_next_blocks_merging

  ; Увеличение размера текущего блока на размер удаляемого блока
  mov rcx, [r8 + 8*1]
  add rcx, [rax + 8*1]
  add rcx, 8*4
  mov [r8 + 8*1], rcx

  ; Удаление заголовка удаляемого блока
  write_header rax, 0, 0, 0, 0

  .skip_current_and_next_blocks_merging:

    ; Нахождение предыдущего блока
    mov rax, r8
    sub rax, [r8 + 8*2]
    sub rax, 8*4

    ; Проверка нахождения блока внутри кучи
    cmp rax, [heap_start]
    jl .skip_previous_and_current_blocks_merging

    ; Если заголовок не найден (блока не существует), пропустить изменение блоков
    mov rbx, [rax]
    cmp rbx, [HEADER_SIGN]
    jne .skip_previous_and_current_blocks_merging

    ; Если следующий блок используется, пропустить изменение блоков
    mov rbx, [rax + 8*3]
    test rbx, 1
    jne .skip_previous_and_current_blocks_merging

    ; Увеличение размера предыдущего блока на размер удаляемого блока
    mov rcx, [r8 + 8*1]
    add rcx, [rax + 8*1]
    add rcx, 8*4
    mov [rax + 8*1], rcx

    ; Удаление заголовка удаляемого блока
    write_header r8, 0, 0, 0, 0
    mov r8, rax

  .skip_previous_and_current_blocks_merging:

    ; Изменение состояния текущего блока
    mov rax, [r8 + 8*3]
    test rax, 1
    jz .all_is_done
    mem_mov [r8 + 8*3], 0

  .all_is_done:

  ; Нахождение дальше идущего блока
  mov rcx, r8
  add rcx, [r8 + 8*1]
  add rcx, 8*4

  ; Проверка нахождения блока внутри кучи
  mov rax, [heap_end]
  cmp rcx, [heap_end]
  jge .skip_next_next_block_modifying

  ; Если заголовок не найден (блока не существует), пропустить изменение блоков
  mov rbx, [rcx]
  cmp rbx, [HEADER_SIGN]
  jne .skip_next_next_block_modifying

  ; Изменение PREV_SIZE для дальше идущего блока
  mem_mov [rcx + 8*2], [r8 + 8*1]

  .skip_next_next_block_modifying:

  ret

section "create_integer" executable

macro create_integer value {
  pushq value
  pushq INTEGER
}

section "create_list" executable

; Запись списка на кучу
;
; Аргументы:
;   list_start — указатель на начало списка
;
; Результат:
;   rax — указатель на созданный блок

macro create_list list_start, length {
  enter_2 list_start, length

  call f_create_list

  leave_with_return
}

f_create_list:
  push rax             ; Сохранение указателя на начало копируемого списка
  push rbx             ; Сохранение длины списка
  mov rcx, LIST_HEADER ; Начальная длина списка

  .do:
    dec rbx

    mov rdx, [rax]
    cmp rdx, INTEGER
    jne .not_integer

    add rcx, 2
    add rax, 8*2
    jmp .while

  .not_integer:
    cmp rax, LIST
    jne .not_list

    add rcx, LIST_HEADER
    add rcx, [rax + 8*1]
    add rax, [rax + 8*2]

    jmp .while

  .not_list:
    check_error jmp, EXPECTED_INTEGER_LIST_TYPE_ERROR

  .while:
    cmp rbx, 0
    jne .do

  mov rbx, rcx
  imul rbx, 8

  ; Аллокация блока на куче
  create_block rbx

  ; Возвращение длины списка
  pop rbx

  write_header rax, LIST, rbx, rcx, 0

  ; RCX — количество блоков
  mov rbx, LIST_HEADER
  sub rcx, rbx
  imul rbx, 8
  mov rdi, rax ; Место назначения
  add rdi, rbx
  pop rsi      ; Источник копирования
  rep movsq    ; Копирование в аллоцированный блок

  ret

section "list_length" executable

macro list_length list_ptr {
  enter_1 list_ptr

  call f_list_length

  leave_with_return
}

f_list_length:
  mov rbx, [rax]
  cmp rbx, LIST
  check_error jne, EXPECTED_LIST_TYPE_ERROR

  mov rax, [rax + 8*1]

  ret

section "list_get" executable

; Запись списка на кучу
;
; Аргументы:
;   list_ptr  — указатель на начало списка
;   index_ptr — указатель на целое число, индекс
;
; Результат:
;   rax — указатель на элемент по индексу

macro list_get list_ptr, index_ptr {
  enter_2 list_ptr, index_ptr

  call f_list_get

  leave_with_return
}

f_list_get:
  ; Проверка типа
  mov rcx, [rax]
  cmp rcx, LIST
  check_error jne, EXPECTED_LIST_TYPE_ERROR

  ; Проверка типа
  mov rcx, [rbx]
  cmp rcx, INTEGER
  check_error jne, EXPECTED_INTEGER_TYPE_ERROR

  ; Запись длины списка
  mov rcx, [rax + 8*1]

  ; Если индекс меньше нуля, то увеличить его на длину списка
  mov rbx, [rbx + 8*1]
  cmp rbx, 0
  jge .positive_index
  add rbx, rcx

  .positive_index:

  ; Проверка, входит ли индекс в список
  cmp rbx, rcx
  check_error jge, INDEX_OUT_OF_LIST_ERROR
  cmp rbx, 0
  check_error jl, INDEX_OUT_OF_LIST_ERROR

	; Получение указателя на тело списка
  mov rcx, rax
  mov rdx, LIST_HEADER
  imul rdx, 8
  add rcx, rdx

  .while:
    dec rbx

    cmp rbx, 0
    jl .while_end

  .do:
    mov rax, [rcx]

    cmp rax, INTEGER
    jne .not_integer

    add rcx, 8*2 ; Смещение на размер заголовка и размер тела
    jmp .while

  .not_integer:
    cmp rax, LIST
    jne .not_list

    mov rax, [rcx + 8*2]
    add rax, LIST_HEADER
    imul rax, 8
    add rcx, rax

    jmp .while

  .not_list:
    check_error jmp, EXPECTED_INTEGER_LIST_TYPE_ERROR

  .while_end:

    mov rax, rcx

  ret

section "string_get" executable

; Запись списка на кучу
;
; Аргументы:
;   string_ptr  — указатель на начало списка
;   index_ptr — указатель на целое число, индекс
;
; Результат:
;   rax — указатель на элемент по индексу

macro string_get string_ptr, index_ptr {
  enter_2 string_ptr, index_ptr

  call f_string_get

  leave_with_return
}

f_string_get:
  ; Проверка типа
  mov rcx, [rax]
  cmp rcx, STRING
  check_error jne, EXPECTED_STRING_TYPE_ERROR

  ; Проверка типа
  mov rcx, [rbx]
  cmp rcx, INTEGER
  check_error jne, EXPECTED_INTEGER_TYPE_ERROR

  ; Запись длины строки
  mov rcx, [rax + 8*1]

  ; Если индекс меньше нуля, то увеличить его на длину строки
  mov rbx, [rbx + 8*1]
  cmp rbx, 0
  jge .positive_index
  add rbx, rcx

  .positive_index:

  ; Проверка, входит ли индекс в строки
  cmp rbx, rcx
  check_error jge, INDEX_OUT_OF_LIST_ERROR
  cmp rbx, 0
  check_error jl, INDEX_OUT_OF_LIST_ERROR

	; Получение указателя на тело строки
  mov rcx, rax
  mov rdx, STRING_HEADER
  imul rdx, 8
  add rcx, rdx

	; Получение элемента по индексу
	add rcx, rbx

	mov rax, rcx

  ret

section "get_file_size" executable

macro get_file_size filename {
  enter_1 filename

  call f_get_file_size

  leave_with_return
}

f_get_file_size:
  mov rbx, rsp
	add rbx, STAT_BUFFER_SIZE

  syscall_2 SYS_STAT,\
            rax,\      ; Указатель на имя файла
            rbx        ; Указатель на место хранения данных

  mov rax, [rbx + 8*6] ; Размер файла в байтах

  ret

section "open_file" executable

macro open_file filename {
  enter_1 filename

  call f_open_file

  leave_with_return
}

f_open_file:
	; Сохранение указателя на имя файла
	mov rbx, rax

  ; Открытие файла
  syscall_2 SYS_OPEN,\
            rax,\      ; Указатель на имя файла
            O_RDONLY   ; Параметры открытия файла

  ; Проверка открытия файла
  cmp rax, 0
  check_error jle, OPENING_FILE_ERROR

	; Сохранение файлового дескриптора
	mov rcx, rax

	; Получене размера файла
	get_file_size rbx

	; Сохранение размера файла
	mov rdx, rax

  create_block 8*4

  mem_mov [rax + 8*0], FILE_DESCRIPTOR ; Тип
  mem_mov [rax + 8*1], rbx             ; Имя файла
  mem_mov [rax + 8*2], rcx             ; Дескриптор
	mem_mov [rax + 8*3], rdx             ; Размер файла

  ret

section "close_file" executable

macro close_file file_descriptor {
  enter_1 file_descriptor

  call f_close_file

  leave_with_return
}

f_close_file:
	; Проверка типа
	mov rbx, [rax]
	cmp rbx, FILE_DESCRIPTOR
  check_error jne, EXPECTED_FILE_DESCRIPTOR_TYPE_ERROR

	mov rbx, rax

  ; Закрываем файл
  syscall_1 SYS_CLOSE,\
            [rax + 8*2] ; Дескриптор файла

	delete_block rbx

  ret

section "read_file" executable

macro read_file file_descriptor {
  enter_1 file_descriptor

  call f_read_file

  leave_with_return
}

f_read_file:
	; Проверка типа
	mov rbx, [rax]
	cmp rbx, FILE_DESCRIPTOR
  check_error jne, EXPECTED_FILE_DESCRIPTOR_TYPE_ERROR

	; Сохранение указателя на файловый дескриптор
	mov rbx, rax

	; Получение размера файла
	mov rax, [rax + 8*3]

	; Сохранение длины строки
	mov rcx, rax

	add rax, 8*2 ; Учёт заголовка бинарной последовательности
	create_block rax

	; Сохранение указателя на блок
	push rax

	mem_mov [rax + 8*0], BINARY
	mem_mov [rax + 8*1], rcx

	add rax, 8*2 ; Сдвиг указателя до тела строки

	; RAX — указатель на созданный блок
	; RBX — указатель на блок файлового дескриптора

  ; Чтение файла
  syscall_3 SYS_READ,\
            [rbx + 8*2],\ ; Файловый дескриптор
            rax,\         ; Блок для хранения данных
            [rbx + 8*3]   ; Размер читаемого файла

	; Проверка, что файл успешно прочитан
  cmp rax, 0
  jge .read
    close_file rbx
		exit_with_message FILE_WAS_NOT_READ_ERROR, -1
  .read:

	mov rbx, rax ; Количество байт в строке

	mov rcx, 0   ; Счётчик
	mov rdi, 0   ; Количество символов

	; Взятие и сохранение указателя на блок
	pop rax
	push rax
	add rax, 8*2 ; Сдвиг указателя до тела строки

	.while_string_length:
		cmp rcx, rbx
		jge .end_string_length

		;	Буфер
		mov rdx, [rax + rcx]
		movzx rdx, dl

		cmp rdx, 248
		check_error jge, UNEXPECTED_BIT_SEQUENCE_ERROR

		cmp rdx, 128
		jl .continue_string_length
		cmp rdx, 192
		jge .continue_string_length

		jmp .do_string_length

	.continue_string_length:
		inc rdi

	.do_string_length:
		inc rcx
		jmp .while_string_length

	.end_string_length:

	pop rsi
	add rsi, 8*2 ; Сдвиг указателя до тела байтовой последовательности

	; RDI — количество символов в строке
	; RSI — Указатель на тело байтовой последовательности

	; Выделение памяти под строку
	mov rax, rdi                    ; Количество символов в строке
	imul rax, 8 * (CHAR_HEADER + 1) ; Нахождение необходимой для всех символов памяти
	add rax, STRING_HEADER*8        ; Учёт заголовка строки

	create_block rax
	push rax ; Сохранение указателя на строку

	mem_mov [rax + 8*0], STRING ; Тип строки
	mem_mov [rax + 8*1], rdi    ; Длина строки

	add rax, 8*2 ; Сдвиг указателя до тела строки

	.while_chars:
		cmp rdi, 0
		je .end_chars

		mov r8, 0 ; Размер символа

		;	Буфер
		mov rdx, [rsi]
		movzx rdx, dl

		; Нахождение символов

		; Символ, занимающий 1 байт (ASCII)
		inc r8
		cmp rdx, 128
		jl .continue_chars

		; Часть другого символа, которого не должно быть в этом месте
		cmp rdx, 192
		check_error jl, UNEXPECTED_BIT_SEQUENCE_ERROR

		; Начало символа, занимающего 2 байта
		inc r8
		cmp rdx, 224
		jl .continue_chars

		; Начало символа, занимающего 3 байта
		inc r8
		cmp rdx, 240
		jl .continue_chars

		; Начало символа, занимающего 4 байта
		inc r8

	  ; Маска первого байта 4-х байтового символа — 1110xxxx₂ (248₁₀)
		cmp rdx, 248
		check_error jge, UNEXPECTED_BIT_SEQUENCE_ERROR

	.continue_chars:
		; Запись символов
		mem_mov [rax + 8*0], CHAR ; Тип
		mem_mov [rax + 8*1], r8   ; Размер символа

		; Сдвиг последовательности до состояния символа
		.while:
			dec r8

			cmp r8, 0
			je .end

			shl rdx, 8
			inc rsi
			mov rbx, [rsi]
			mov dl, bl
			jmp .while

		.end:

		mem_mov [rax + 8*2], rdx
		add rax, 8*3
		inc rsi

		dec rdi
		jmp .while_chars

	.end_chars:

	; Взятие указателя на блок
	pop rax

  ret

section "get_string_length" executable

macro get_string_length string_addr {
  enter_1 string_addr

  call f_get_string_length

  leave_with_return
}

f_get_string_length:
	; Проверка типа
	mov rbx, [rax]
	cmp rbx, STRING
  check_error jne, EXPECTED_STRING_TYPE_ERROR

	mov rax, [rax + 8*1]
	ret

section "get_string" executable

macro get_string string_addr, index {
  enter_2 string_addr, index

  call f_get_string

  leave_with_return
}

f_get_string:
	; Проверка типа
	mov rcx, [rax]
	cmp rcx, STRING
  check_error jne, EXPECTED_STRING_TYPE_ERROR

	add rax, STRING_HEADER*8

	; Проверка типа
	mov rcx, [rbx]
	cmp rcx, INTEGER
  check_error jne, EXPECTED_INTEGER_TYPE_ERROR

	mov rbx, [rbx+8]

	imul rbx, 3*8
	add rax, rbx

	ret

section "start" executable
_start:
	allocate_heap

	; Получение размера файла
	print_buffer FILE_SIZE
	get_file_size filename
	print_int rax

	;	Открытие файла
	open_file filename
	mov [файловый_дескриптор], rax

	; Чтение файла
	read_file [файловый_дескриптор]
	mov [содержимое_файла], rax

	; Закрытие файла, дальше он не нужен
	close_file [файловый_дескриптор]

	; Получение длины строки
	print_buffer STRING_SIZE
	get_string_length [содержимое_файла]
	print_int rax

	; Вывод содержимого файла
	print_buffer STRING_CONTENT
	print_string [содержимое_файла]

	; Взятие символа по индексу
	create_integer 27
	mov [индекс], rsp
	get_string [содержимое_файла], [индекс]

	print_buffer CHAR_BY_INDEX
	mov [символ], rax
	print_string [символ]

	; Расширение кучи
	expand_heap 0x1000

	; список = 1 2 3 4
	create_integer 4
	create_integer 3
	create_integer 2
	create_integer 1

	mov rax, rsp       ; Указатель на начало списка
	create_list rax, 4 ; Количество элементов
	mov [список], rax

	; индекс = 999
	create_integer -1
	mov [индекс], rsp

	; список.индекс
	list_get [список], [индекс]
	mov rax, [rax + 8*1]

	; показать(список.индекс)
	print_int rax

  exit 0
