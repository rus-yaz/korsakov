;format ELF64 executable
;entry _start

format ELF64
public _start

section "data" writable
	; Системные вызовы
	define SYS_MMAP   9
	define SYS_MUNMAP 11
	define SYS_EXIT   60

	; Куча
	HEADER_SIGN dq 0xFEDCBA9876543210 ; Обозначение начала заголовка блока, выделяемого на куче
	HEAP_SIZE   dq 0x1000             ; Начальный размер кучи
	heap_start  rq 1                  ; Указатель на начало кучи
	heap_end    rq 1                  ; Указатель на конец кучи

	; Типы данных
	NULL       dq 0
	INTEGER    dq 1
	FLOAT      dq 2
	LIST       dq 3
	STRING     dq 4
	DICTIONARY dq 5
	FUNCTION   dq 6
	CLASS      dq 7

	; Размер заголовка типов данных
	NULL_HEADER       dq 0
	INTEGER_HEADER    dq 1
	FLOAT_HEADER      dq 0
	LIST_HEADER       dq 3
	STRING_HEADER     dq 0
	DICTIONARY_HEADER dq 0
	FUNCTION_HEADER   dq 0
	CLASS_HEADER      dq 0

	; Переменные для тестов работы кучи
	список rq 1
	индекс rq 1

	; Сообщения об ошибках
	HEAP_ALLOCATION_ERROR db "Ошибка аллокации кучи", 10, 0
	EXPECTED_INTEGER_TYPE_ERROR db "Ожидался тип Целое число", 10, 0
	EXPECTED_LIST_TYPE_ERROR db "Ожидался тип Список", 10, 0
	EXPECTED_INTEGER_LIST_TYPE_ERROR db "Ожидался тип Целое число или Список", 10, 0
	EXPECTED_HEAP_BLOCK_ERROR db "Ожидался блок кучи", 10, 0
	INDEX_OUT_OF_LIST_ERROR db "Индекс выходит за пределы списка", 10, 0

section "exit" executable

; Выход из программы
;
; Аргументы:
;   code — код выхода

macro exit code {
	mov rdi, code     ; Код выхода
	mov rax, SYS_EXIT ; Код сигнала выхода
	syscall
}

section "error_exit" executable

macro error_exit operation, message {
	push rax
	mov rax, message
	operation f_error_exit
	pop rax
}

; Сокращение для выхода с кодом 1
f_error_exit:
	mov rsi, rax
	mov rdx, 0 ; rcx будет хранить количество байт для сравнения (0)

	.loop:
	   ; Сравниваем текущий байт с нулем
	   mov bl, [rax + rdx]   ; Загружаем текущий байт в al
	   cmp bl, 0             ; Проверяем, равен ли байт нулю
	   je .done              ; Если равен нулю, выходим из цикла

	   inc rdx               ; Увеличиваем счетчик
	   jmp .loop             ; Переход к следующей итерации

	.done:

	mov rax, 1
	mov rdi, 1
	syscall

	exit -1


section "regs_operations" executable

macro pushq val {
	mov rax, val
	push rax
}

; Упрощение обмена между фрагментами памяти
;
; Аргументы:
;   dst — приёмник
;   src — источник
macro mem_mov dst, src {
	push r15
	mov r15, src
	mov dst, r15
	pop r15
}

; Установка заголовка блока
;
; Аргументы:
;   addr        — указатель на заголовок блока
;   header_sign — метка заголовка блока
;   size        — размер тела блока
;   prev_size   — размер тела предыдущего блока
;   state       — состояние использования блока
macro write_header addr, header_sign, size, prev_size, state {
	mem_mov [addr + 8*0], header_sign
	mem_mov [addr + 8*1], size
	mem_mov [addr + 8*2], prev_size
	mem_mov [addr + 8*3], state
}

; Сохранение всех регистров на стеке
macro save_all_regs {
	push rax
	push rbx
	push rcx
	push rdx
	push rsi
	push rdi
	push r8
	push r9
	push r10
	push r11
	push r12
	push r13
	push r14
	push r15
}

; Взятие всех регистров со стека
macro restore_all_regs {
	pop r15
	pop r14
	pop r13
	pop r12
	pop r11
	pop r10
	pop r9
	pop r8
	pop rdi
	pop rsi
	pop rdx
	pop rcx
	pop rbx
	pop rax
}

section "allocate_heap" executable

; Алллокация кучи с сохранением указателей на начало и конец кучи
;
; Аргументы:
;   HEAP_SIZE — размер выделяемой кучи
;
; Результат:
;   heap_start — указатель на начало кучи
;   heap_end   — указатель на начало кучи

macro allocate_heap {
	save_all_regs

	call f_allocate_heap

	restore_all_regs
}

f_allocate_heap:
	mov rsi, [HEAP_SIZE]     ; Количество памяти для аллокации
	mov rax, SYS_MMAP ; Код системного вызова для MMAP
	mov rdi, 0        ; Адрес (если 0, нахоходится автоматически)
	mov rdx, 7        ; Права (PROT_READ | PROT_WRITE)
	mov r8, 0         ; Файл дескриптор (ввод)
	mov r9, 0         ; Смещение относительно начала файла (с начала файла)
	mov r10, 34       ; Что-то (MAP_ANONYMOUS | MAP_PRIVATE)
	syscall

	; Проверка корректности выделения памяти
	test rax, rax
	error_exit js, HEAP_ALLOCATION_ERROR

	; Сохранение указателя на начало кучи
	mov [heap_start], rax

	mov rbx, [HEAP_SIZE]                       ; Запись размера кучи
	sub rbx, 8*4                               ; Учёт размера заголовка блока
	write_header rax, [HEADER_SIGN], rbx, 0, 0 ; Запись заголовка начального блока

	mov rax, [heap_start] ; Запись указателя на начало кучи
	add rax, [HEAP_SIZE]  ; Смещение на размер кучи
	mov [heap_end], rax   ; Сохранение указателя на конец кучи

	ret

section "expand_heap" executable

; Расширение кучи
;
; Аргументы:
;   size — количество памяти, на которое необходимо расширить кучу
;
; Результат:
;   heap_start — указатель на начало кучи
;   heap_end   — указатель на начало кучи

macro expand_heap size {
	save_all_regs

	mov rax, size
	call f_expand_heap

	restore_all_regs
}

f_expand_heap:
	; Сохранение количества памяти для расширения
	mov rcx, rax

	; Получение итогового размера кучи
	add rax, [HEAP_SIZE]
	mov [HEAP_SIZE], rax

	; Взятие указателя на начало кучи
	mov rax, [heap_start]

	; Аллокация новой кучи
	allocate_heap

	; RDI — указатель на новую кучу
	; RSI — указатель на старую кучу
	mov rdi, [heap_start]
	mov rsi, rax

	; Сохранение указателя на старую кучу
	mov r8, rsi

	; Получение размера старой кучи
	mov rax, [HEAP_SIZE]
	sub rax, rcx

	; Сохранение размера старой кучи
	mov r9, rax

	; Расчёт количества операций для копирования
	push rax
	mov rcx, 8
	idiv rcx
	mov rcx, rax
	pop rax

	; Копирование данных со старой кучи в новую
	rep movsq

	; Укзатель на начало новой кучи
	mov rbx, [heap_start]

	; Поиск последнего блока кучи
	.while:
		mov rcx, rbx
		add rbx, [rbx + 8*1]
		add rbx, 8*4

		mov rdx, [rbx]
		cmp rdx, [HEADER_SIGN]
		je .while

	; Расширение последнего блока до конца кучи
	mov rbx, [rcx + 8*1]
	add rbx, rax
	mov [rcx + 8*1], rbx

	; Деаллокация старой кучи
	mov rax, SYS_MUNMAP
	mov rdi, r8
	mov rsi, r9
	syscall

	ret

section "create_block" executable

; Аллоакция места на куче для блока определённого размера
;
; Аргументы:
;   size — количество памяти, выделяемой на тело блока
;
; Результат:
;   rax — указатель на тело блока

macro create_block size {
	save_all_regs

	mov rax, size
	call f_create_block

	push rax
	add rsp, 8

	restore_all_regs
	mov rax, [rsp - 8*15]
}

f_create_block:
	mov r8, rax

	mov rax, [heap_start] ; Запись указателя на начало кучи в RAX

	; Цикл для нахождения подходящего блока
	.do:
		; Если заголовок не найден, выйти с ошибкой
		mov rdx, [rax]
		cmp rdx, [HEADER_SIGN]
		error_exit jne, EXPECTED_HEAP_BLOCK_ERROR

		; Если блок используется, начать искать новый блок
		mov rdx, [rax + 8*3]
		test rdx, 1
		js .condition

		; Сравнение выделенного размера и размера блока
		mov rdx, [rax + 8*1]
		cmp rdx, r8
		jge .continue

	.condition:
		add rax, [rax + 8*1] ; Смещение адреса текущего блока на его размер
		add rax, 8*4         ; Смещение адреса текущего указателя на размер заголовка

		jmp .do  ; Переход к началу цикла

	; Окончание цикла
	.continue:
		; Вычисление адреса нового блока
		mov rbx, rax
		add rbx, 8*4
		add rbx, r8

		; Проверка состояния блока
		mov rcx, [rbx + 8*3]
		test rcx, 1
		jnz .do

	.modify_block:

	mem_mov [rax + 8*3], 1 ; Изменение состояния текущего блока на используемое

	mov rcx, [rax + 8*1]    ; Сохранение размера текущего блока в RCX
	sub rcx, r8             ; Вычисление размера текущего блока в RCX
	sub rcx, 8*4            ; Учёт размера заголовка
	mem_mov [rax + 8*1], r8 ; Изменение SIZE у предыдущего блока

	; KEY
	; SIZE
	; PREV_SIZE
	; STATE
	write_header rbx, [HEADER_SIGN], rcx, r8, 0

	add rax, 8*4

	ret

section "delete_block" executable

; Удаление блока по указателю
;
; Аргументы:
;   block_addr — указатель на блок
macro delete_block block_addr {
	save_all_regs

	mov rax, block_addr
	call f_delete_block

	restore_all_regs
}

f_delete_block:
	sub rax, 8*4

	mov r8, rax

	; Если заголовок не найден, выйти с ошибкой
	mov rax, [r8]
	cmp rax, [HEADER_SIGN]
	error_exit jne, EXPECTED_HEAP_BLOCK_ERROR

	; Объединение текущего блока и следующего, если он не используется

	; Нахождение следующего блока
	mov rax, r8
	add rax, 8*4
	add rax, [r8 + 8*1]

	; Если заголовок не найден (блока не существует), пропустить изменение блоков
	mov rbx, [rax]
	cmp rbx, [HEADER_SIGN]
	jne .skip_current_and_next_blocks_merging

	; Если следующий блок используется, пропустить изменение блоков
	mov rbx, [rax + 8*3]
	test rbx, 1
	jne .skip_current_and_next_blocks_merging

	; Увеличение размера текущего блока на размер удаляемого блока
	mov rcx, [r8 + 8*1]
	add rcx, [rax + 8*1]
	add rcx, 8*4
	mov [r8 + 8*1], rcx

	; Удаление заголовка удаляемого блока
	write_header rax, 0, 0, 0, 0

	.skip_current_and_next_blocks_merging:

		; Нахождение предыдущего блока
		mov rax, r8
		sub rax, [r8 + 8*2]
		sub rax, 8*4

		; Проверка нахождения блока внутри кучи
		cmp rax, [heap_start]
		jl .skip_previous_and_current_blocks_merging

		; Если заголовок не найден (блока не существует), пропустить изменение блоков
		mov rbx, [rax]
		cmp rbx, [HEADER_SIGN]
		jne .skip_previous_and_current_blocks_merging

		; Если следующий блок используется, пропустить изменение блоков
		mov rbx, [rax + 8*3]
		test rbx, 1
		jne .skip_previous_and_current_blocks_merging

		; Увеличение размера предыдущего блока на размер удаляемого блока
		mov rcx, [r8 + 8*1]
		add rcx, [rax + 8*1]
		add rcx, 8*4
		mov [rax + 8*1], rcx

		; Удаление заголовка удаляемого блока
		write_header r8, 0, 0, 0, 0
		mov r8, rax

	.skip_previous_and_current_blocks_merging:

		; Изменение состояния текущего блока
		mov rax, [r8 + 8*3]
		test rax, 1
		jz .all_is_done
		mem_mov [r8 + 8*3], 0

	.all_is_done:

	; Нахождение дальше идущего блока
	mov rcx, r8
	add rcx, [r8 + 8*1]
	add rcx, 8*4

	; Проверка нахождения блока внутри кучи
	mov rax, [heap_end]
	cmp rcx, [heap_end]
	jge .skip_next_next_block_modifying

	; Если заголовок не найден (блока не существует), пропустить изменение блоков
	mov rbx, [rcx]
	cmp rbx, [HEADER_SIGN]
	jne .skip_next_next_block_modifying

	; Изменение PREV_SIZE для дальше идущего блока
	mem_mov [rcx + 8*2], [r8 + 8*1]

	.skip_next_next_block_modifying:

	ret

section "create_integer" executable

macro create_integer value {
	pushq value
	pushq INTEGER
}

section "create_list" executable

; Запись списка на кучу
;
; Аргументы:
;   list_start — указатель на начало списка
;
; Результат:
;   rax — указатель на созданный блок

macro create_list list_start, length {
	save_all_regs

	mov rax, list_start
	mov rbx, length
	call f_create_list

	push rax
	add rsp, 8

	restore_all_regs
	mov rax, [rsp - 8*15]
}

f_create_list:
	; Сохранение указателя на начало копируемого списка и длины списка
	push rax
	push rbx

	mov rcx, [LIST_HEADER]

	.do:
		dec rbx

		mov rdx, [rax]
		cmp rdx, INTEGER
		jne .not_integer

		add rcx, 2
		add rax, 8*2
		jmp .while

	.not_integer:
		cmp rax, LIST
		jne .not_list

		add rcx, LIST_HEADER
		add rcx, [rax + 8*1]
		add rax, [rax + 8*2]

		jmp .while

	.not_list:
		error_exit jmp, EXPECTED_INTEGER_LIST_TYPE_ERROR

	.while:
		cmp rbx, 0
		jne .do

	mov rbx, rcx
	imul rbx, 8

	; Аллокация блока на куче
	create_block rbx

	; Возвращение длины списка
	pop rbx

	write_header rax, LIST, rbx, rcx, 0

	; RCX — количество блоков
	mov rbx, [LIST_HEADER]
	sub rcx, rbx
	imul rbx, 8
	mov rdi, rax ; Место назначения
	add rdi, rbx
	pop rsi      ; Источник копирования
	rep movsq    ; Копирование в аллоцированный блок

	ret

section "list_length" executable

macro list_length list_ptr {
	save_all_regs

	mov rax, list_ptr
	call f_list_length

	push rax
	add rsp, 8

	restore_all_regs
	mov rax, [rsp - 8*15]
}

f_list_length:
	mov rbx, [rax]
	cmp rbx, LIST
	error_exit jne, EXPECTED_LIST_TYPE_ERROR

	mov rax, [rax + 8*1]

	ret

section "list_get" executable

; Запись списка на кучу
;
; Аргументы:
;   list_ptr  — указатель на начало списка
;   index_ptr — указатель на целое число, индекс
;
; Результат:
;   rax — указатель на элемент по индексу

macro list_get list_ptr, index_ptr {
	save_all_regs

	mov rax, list_ptr
	mov rbx, index_ptr
	call f_list_get

	push rax
	add rsp, 8

	restore_all_regs
	mov rax, [rsp - 8*15]
}

f_list_get:
	; Проверка типа
	mov rcx, [rax]
	cmp rcx, LIST
	error_exit jne, EXPECTED_LIST_TYPE_ERROR

	; Проверка типа
	mov rcx, [rbx]
	cmp rcx, INTEGER
	error_exit jne, EXPECTED_INTEGER_TYPE_ERROR

	; Запись длины списка
	mov rcx, [rax + 8*1]

	; Если индекс меньше нуля, то увеличить его на длину списка
	mov rbx, [rbx + 8*1]
	cmp rbx, 0
	jge .positive_index
	add rbx, rcx

	.positive_index:

	; Проверка, входит ли индекс в список
	cmp rbx, rcx
	error_exit jge, INDEX_OUT_OF_LIST_ERROR
	cmp rbx, 0
	error_exit jl, INDEX_OUT_OF_LIST_ERROR

	mov rcx, rax
	mov rdx, [LIST_HEADER]
	imul rdx, 8
	add rcx, rdx

	.while:
		dec rbx

		cmp rbx, 0
		jl .while_end

	.do:
		mov rax, [rcx]

		cmp rax, INTEGER
		jne .not_integer

		add rcx, 8*2 ; Смещение на размер заголовка и размер тела
		jmp .while

	.not_integer:
		cmp rax, LIST
		jne .not_list

		mov rax, [rcx + 8*2]
		add rax, [LIST_HEADER]
		imul rax, 8
		add rcx, rax

		jmp .while

	.not_list:
		error_exit jmp, EXPECTED_INTEGER_LIST_TYPE_ERROR

	.while_end:

		mov rax, rcx

	ret

_start:

	;; Аллокация кучи
	;allocate_heap
	;
	;; Расширение кучи
	;expand_heap 0x1000
	;
	;; список = 1 2 3 4
	;create_integer 4
	;create_integer 3
	;create_integer 2
	;create_integer 1
	;
	;mov rax, rsp ; Указатель на начало списка
	;create_list rax, 4 ; Количество элементов
	;
	;mov [список], rax
	;
	;; индекс = 999
	;create_integer 999
	;mov [индекс], rsp
	;
	;; список.индекс
	;list_get [список], [индекс]

	exit [rax + 8*1] ; Показать значение взятогого элемента
