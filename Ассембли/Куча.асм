;format ELF64 executable
;entry _start

format ELF64
public _start

; Системные вызовы
define SYS_MMAP 9
define SYS_MUNMAP 11
define SYS_EXIT 60

; Куча
HEADER_SIGN dq 0xFEDCBA9876543210 ; Обозначение начала заголовка блока, выделяемого на куче
HEAP_SIZE dq 0x1000               ; Начальный размер кучи
heap_start rq 1                   ; Указатель на начало кучи
heap_end rq 1                     ; Указатель на конец кучи

; Переменные для тестов работы кучи
block_1 rq 1
block_2 rq 1
block_3 rq 1
block_4 rq 1

; Упрощене обмена между фрагментами памяти
macro mem_mov dst, src {
	push r15
	mov r15, src
	mov dst, r15
	pop r15
}

; Установка заголовка блока
;
; reg — указатель на заголовок блока
; header_sign — метка заголовка блока
; size — размер тела блока
; prev_size — размер тела предыдущего блока
; state — состояние использования блока
macro write_header reg, header_sign, size, prev_size, state {
	mem_mov [reg + 8*0], header_sign
	mem_mov [reg + 8*1], size
	mem_mov [reg + 8*2], prev_size
	mem_mov [reg + 8*3], state
}

section "regs_operations" executable

macro save_all_regs {
	push rax
	push rbx
	push rcx
	push rdx
	push rsi
	push rdi
	push r8
	push r9
	push r10
	push r11
	push r12
	push r13
	push r14
	push r15
}

macro restore_all_regs {
	pop r15
	pop r14
	pop r13
	pop r12
	pop r11
	pop r10
	pop r9
	pop r8
	pop rdi
	pop rsi
	pop rdx
	pop rcx
	pop rbx
	pop rax
}

section "allocate_heap" executable

macro allocate_heap {
	save_all_regs

	call f_allocate_heap

	restore_all_regs
}

; Алллокация кучи с сохранением указателей на начало и конец кучи
f_allocate_heap:
	mov rsi, [HEAP_SIZE]     ; Количество памяти для аллокации
	mov rax, SYS_MMAP ; Код системного вызова для MMAP
	mov rdi, 0        ; Адрес (если 0, нахоходится автоматически)
	mov rdx, 7        ; Права (PROT_READ | PROT_WRITE)
	mov r8, 0         ; Файл дескриптор (ввод)
	mov r9, 0         ; Смещение относительно начала файла (с начала файла)
	mov r10, 34       ; Что-то (MAP_ANONYMOUS | MAP_PRIVATE)
	syscall

	; Проверка корректности выделения памяти
	test rax, rax
	js error_exit
	mov [heap_start], rax ; Сохранение указателя на начало кучи

	mov rbx, [HEAP_SIZE]                       ; Запись размера кучи
	sub rbx, 8*4                               ; Учёт размера заголовка блока
	write_header rax, [HEADER_SIGN], rbx, 0, 0 ; Запись заголовка начального блока

	mov rax, [heap_start] ; Запись указателя на начало кучи
	add rax, [HEAP_SIZE]  ; Смещение на размер кучи
	mov [heap_end], rax   ; Сохранение указателя на конец кучи

	ret

section "expand_heap" executable

; Расширение кучи
;
; size — количество памяти, на которое необходимо расширить кучу
macro expand_heap size {
	save_all_regs

	mov rax, size
	call f_expand_heap

	restore_all_regs
}

; Расширение кучи
;
; rax — количество памяти, на которое необходимо расширить кучу
f_expand_heap:
	mov rcx, rax

	add rax, [HEAP_SIZE]
	mov [HEAP_SIZE], rax

	mov rax, [heap_start]

	allocate_heap

	mov rdi, [heap_start]
	mov rsi, rax
	mov r8, rsi

	mov rax, [HEAP_SIZE]
	sub rax, rcx
	mov rcx, 8
	div rcx
	mov rcx, rax

	mov rbx, 8
	mul rbx
	mov r9, rax

	rep movsq

	mov rbx, [heap_start]
expand_heap_while:
	mov rcx, rbx
	add rbx, [rbx + 8*1]
	add rbx, 8*4

	mov rdx, [rbx]
	cmp rdx, [HEADER_SIGN]
	je expand_heap_while

	mov rbx, [rcx + 8*1]
	add rbx, rax
	mov [rcx + 8*1], rbx

	mov rax, SYS_MUNMAP
	mov rdi, r8
	mov rsi, r9
	syscall

	ret

section "create_block" executable

; INPUT
; memory_to_allocate — количество памяти, выделяемой на тело блока
macro create_block memory_to_allocate {
	save_all_regs

	; Нормализация размера записываемого блока
	if memory_to_allocate mod (8*4)
		size = memory_to_allocate + 8*4 - memory_to_allocate mod (8*4)
	else
		size = memory_to_allocate
	end if

	mov rax, size
	call f_create_block

	push rax
	add rsp, 8

	restore_all_regs
	mov rax, [rsp - 8*15]
}

; INPUT
; RAX — размер тела выделяемого блока
; ----------
; OUTPUT
; RAX — адрес на тело выделенного блока
f_create_block:
	mov r8, rax

	mov rax, [heap_start] ; Запись указателя на начало кучи в RAX

	; Цикл для нахождения подходящего блока
	create_block_do:
		; Если заголовок не найден, выйти с ошибкой
		mov rdx, [rax]
		cmp rdx, [HEADER_SIGN]
		jne error_exit

		; Если блок используется, начать искать новый блок
		mov rdx, [rax + 8*3]
		test rdx, 1
		jnz create_block_condition

		; Сравнение выделенного размера и размера блока
		mov rdx, [rax + 8*1]
		cmp rdx, r8
		jge create_block_continue

	create_block_condition:
		add rax, [rax + 8*1] ; Смещение адреса текущего блока на его размер
		add rax, 8*4         ; Смещение адреса текущего указателя на размер заголовка

		jmp create_block_do  ; Переход к началу цикла

	; Окончание цикла
	create_block_continue:
		; Вычисление адреса нового блока
		mov rbx, rax
		add rbx, 8*4
		add rbx, r8

		; Проверка состояния блока
		mov rcx, [rbx + 8*3]
		test rcx, 1
		jnz create_block_do

	create_block_modify_block:

	mem_mov [rax + 8*3], 1 ; Изменение состояния текущего блока на используемое

	mov rcx, [rax + 8*1]    ; Сохранение размера текущего блока в RCX
	sub rcx, r8             ; Вычисление размера текущего блока в RCX
	sub rcx, 8*4            ; Учёт размера заголовка
	mem_mov [rax + 8*1], r8 ; Изменение SIZE у предыдущего блока

	; KEY
	; SIZE
	; PREV_SIZE
	; STATE
	write_header rbx, [HEADER_SIGN], rcx, r8, 0

	add rax, 8*4

	ret

section "delete_block" executable

; INPUT
; address_of_block_to_be_deleted — addr
macro delete_block address_of_block_to_be_deleted {
	save_all_regs

	mov rax, address_of_block_to_be_deleted
	call f_delete_block

	push rax
	add rsp, 8

	restore_all_regs
	mov rax, [rsp - 8*15]
}

; INPUT
; RAX — addr
f_delete_block:
	sub rax, 8*4

	mov r8, rax

	; Если заголовок не найден, выйти с ошибкой
	mov rax, [r8]
	cmp rax, [HEADER_SIGN]
	jne error_exit

	; Объединение текущего блока и следующего, если он не используется

	; Нахождение следующего блока
	mov rax, r8
	add rax, 8*4
	add rax, [r8 + 8*1]

	; Если заголовок не найден (блока не существует), пропустить изменение блоков
	mov rbx, [rax]
	cmp rbx, [HEADER_SIGN]
	jne delete_block_skip_current_and_next_blocks_merging

	; Если следующий блок используется, пропустить изменение блоков
	mov rbx, [rax + 8*3]
	test rbx, 1
	jne delete_block_skip_current_and_next_blocks_merging

	; Увеличение размера текущего блока на размер удаляемого блока
	mov rcx, [r8 + 8*1]
	add rcx, [rax + 8*1]
	add rcx, 8*4
	mov [r8 + 8*1], rcx

	; Удаление заголовка удаляемого блока
	write_header rax, 0, 0, 0, 0

	delete_block_skip_current_and_next_blocks_merging:

		; Нахождение предыдущего блока
		mov rax, r8
		sub rax, [r8 + 8*2]
		sub rax, 8*4

		; Проверка нахождения блока внутри кучи
		cmp rax, [heap_start]
		jl delete_block_skip_previous_and_current_blocks_merging

		; Если заголовок не найден (блока не существует), пропустить изменение блоков
		mov rbx, [rax]
		cmp rbx, [HEADER_SIGN]
		jne delete_block_skip_previous_and_current_blocks_merging

		; Если следующий блок используется, пропустить изменение блоков
		mov rbx, [rax + 8*3]
		test rbx, 1
		jne delete_block_skip_previous_and_current_blocks_merging

		; Увеличение размера предыдущего блока на размер удаляемого блока
		mov rcx, [r8 + 8*1]
		add rcx, [rax + 8*1]
		add rcx, 8*4
		mov [rax + 8*1], rcx

		; Удаление заголовка удаляемого блока
		write_header r8, 0, 0, 0, 0
		mov r8, rax

	delete_block_skip_previous_and_current_blocks_merging:

		; Изменение состояния текущего блока
		mov rax, [r8 + 8*3]
		test rax, 1
		jz delete_block_all_is_done
		mem_mov [r8 + 8*3], 0

	delete_block_all_is_done:

	; Нахождение дальше идущего блока
	mov rcx, r8
	add rcx, [r8 + 8*1]
	add rcx, 8*4

	; Проверка нахождения блока внутри кучи
	mov rax, [heap_end]
	cmp rcx, [heap_end]
	jge skip_next_next_block_modifying

	; Если заголовок не найден (блока не существует), пропустить изменение блоков
	mov rbx, [rcx]
	cmp rbx, [HEADER_SIGN]
	jne skip_next_next_block_modifying

	; Изменение PREV_SIZE для дальше идущего блока
	mem_mov [rcx + 8*2], [r8 + 8*1]

	skip_next_next_block_modifying:

	ret

section "exit" executable

; INPUT
; code — exit code
macro exit code {
	mov rax, SYS_EXIT ; syscall number for exit
	mov rdi, code     ; Exit Code
	syscall           ; Make the system call
}

error_exit:
	exit 1              ; Status code 1 (exit with error)

_start:
	allocate_heap

	create_block 0x100

	nop
	nop
	nop
	nop
	nop
	nop

	expand_heap [HEAP_SIZE]

	exit 0
