is_square_matrix = функция является_квадратной_матрицей(матрица): длина(матрица) == длина(матрица.0)

transpose_matrix = функция транспонировать_матрицу(матрица): для а от 0 до длина(матрица.0): для б от 0 до длина(матрица): матрица.б.а

matrix_multiplication = матричное_умножение = функция произведение_матриц(первая_матрица, вторая_матрица)
  если длина(первая_матрица.0) != длина(вторая_матрица) то
    ошибка("Количество элементов в строке первой матрицы не равно количеству элементов в столбце второй матрицы")
  ---

  строки_итоговой_матрицы = длина(первая_матрица.0)
  столбцы_итоговой_матрицы = длина(вторая_матрица)

  итоговая_матрица = %()%
  для а от 0 до строки_итоговой_матрицы
    строка = %()%
    для б от 0 до столбцы_итоговой_матрицы
      элемент = 0

      для счётчик от 0 до столбцы_итоговой_матрицы
        элемент += первая_матрица.а.счётчик * вторая_матрица.счётчик.б
      ---

      строка += %(элемент)%
    ---
    итоговая_матрица += %(строка)%
  ---

  вернуть итоговая_матрица
---

multiply_matrix_by_number = функция умножение_матрицы_на_число(матрица, число)
  вернуть для строка из матрица: для элемент из строка: число * элемент
---

find_minor = функция найти_минор(матрица, удаляемая_строка, удаляемый_столбец=нуль)
  порядок_матрицы = длина(матрица)
  результат = %()%

  для строка от 0 до порядок_матрицы
    если строка == удаляемая_строка то продолжить

    новая_строка = %()%

    для столбец от 0 до порядок_матрицы
      если столбец == удаляемый_столбец то продолжить

      новая_строка += %(матрица.строка.столбец)%
    ---

    результат += %(новая_строка)%
  ---

  вернуть результат
---

find_determinant = функция найти_определитель(матрица)
  порядок_матрицы = длина(матрица)
  если порядок_матрицы == 2 то вернуть матрица.0.0 * матрица.1.1 - матрица.0.1 * матрица.1.0

  значение_определителя = 0

  для а из диапазон(порядок_матрицы)
    значение_определителя += (-1)**а * матрица.0.а * найти_определитель(найти_минор(матрица, 0, а))
  ---

  вернуть значение_определителя
---

find_algegraic_additions_matrix = функция найти_матрицу_алгебраических_дополнений(матрица)
  порядок_матрицы = длина(матрица)
  вернуть для строка от 0 до порядок_матрицы: для столбец от 0 до порядок_матрицы: (-1)**(строка + столбец) * найти_определитель(найти_минор(матрица, строка, столбец))
---

find_inverse_matrix = функция найти_обратную_матрицу(матрица)
  вернуть умножение_матрицы_на_число(
    найти_матрицу_алгебраических_дополнений(транспонировать_матрицу(матрица)),
    найти_определитель(матрица)**-1
  )
---

find_matrix_rank = функция найти_ранг_матрицы(матрица)
  если не матрица то вернуть 0

  строки = длина(матрица)
  столбцы = длина(матрица.0)

  ранг = наименьшее(%(строки, столбцы)%)

  для строка из диапазон(строки)
    если не ранг то прервать

    пивот = -1
    для столбец из диапазон(столбцы)
      если матрица.строка.столбец != 0 то
        пивот = столбец
        прервать
      ---
    ---

    если пивот == -1 то
      ранг--
    иначе
      для а из диапазон(строка + 1, строки)
        множитель = матрица.а.пивот / матрица.строка.пивот
        для б из диапазон(столбцы)
          матрица.а.б -= множитель * матрица.строка.б
        ---
      ---
    ---
  ---

  вернуть ранг
---
